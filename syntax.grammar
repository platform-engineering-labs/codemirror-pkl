@precedence {
  AmendmentDeclaration,
  ModuleDeclaration,
  ImportDeclaration,
  assignment,
  lambdaParams @right,
  lambda @right,
  statement,
  member @left,
  call @left,
  typeArgs,
  pipe @left,
  nullCoalesce @left,
  logicalOr @left,
  logicalAnd @left,
  equality @left,
  comparison @left,
  additive @left,
  multiplicative @left,
  power @right,
  typeUnion @left,
  unary,
  ifElse @right,
  ifOnly
}

@top Program { (AmendmentDeclaration? | ModuleDeclaration?) ImportDeclaration* statement* }

@skip { space | LineComment | BlockComment | DocComment }

kw<term> { @specialize[@name={term}]<Identifier, term> }

AmendmentDeclaration {
  kw<"amends"> String
}

ImportDeclaration {
  kw<"import"> String (kw<"as"> Identifier)?
}

ModuleDeclaration {
  kw<"module"> ModuleName
}

Assignment {
  modifiers? Definition (":" !assignment typeExpression)? "=" expression
}

ObjectDeclaration {
  modifiers? Definition "{" statement* "}"
}

statement {
  Boolean |
  Identifier |
  String |
  Number |
  Assignment |
  ObjectDeclaration |
  FunctionDeclaration |
  ClassDeclaration |
  TypeAliasDeclaration |
  ControlStatement |
  ";"
}

ControlStatement {
  kw<"when"> "(" expression ")" Block |
  kw<"when"> expression |
  ForStatement |
  kw<"let"> expression |
  kw<"read"> expression |
  kw<"read"> "?" expression |
  kw<"throw"> expression |
  kw<"trace"> expression
}

ForStatement {
  kw<"for"> "(" ForVariable ("," ForVariable)* kw<"in"> expression ")" Block
}

ForVariable {
  Definition ~forVariable
}

FunctionDeclaration {
  modifiers? kw<"function"> Definition "(" parameterList? ")" (":" typeExpression)? "=" expression
}

parameterList {
  parameter ("," parameter)*
}

parameter {
  Definition (":" typeExpression)? ("=" expression)?
}



ClassDeclaration {
  modifiers? kw<"class"> Identifier "{" statement* "}"
}

TypeAliasDeclaration {
  modifiers? kw<"typealias"> Identifier "=" typeExpression
}

// Fixed type expressions to avoid circular references
typeExpression {
  UnionType
}

UnionType {
  UnionType !typeUnion "|" TypeAtom |
  TypeAtom
}

TypeAtom {
  SimpleType |
  NullableType |
  ParenthesizedType
}

SimpleType {
  (BuiltinType | QualifiedType | Identifier) TypeArguments?
}

QualifiedType {
  Identifier (!member "." Identifier)+
}

BuiltinType {
  kw<"String"> |
  kw<"Int"> |
  kw<"Int8"> |
  kw<"Int16"> |
  kw<"Int32"> |
  kw<"UInt"> |
  kw<"UInt8"> |
  kw<"UInt16"> |
  kw<"UInt32"> |
  kw<"Float"> |
  kw<"Boolean"> |
  kw<"Duration"> |
  kw<"DataSize"> |
  kw<"Uri"> |
  kw<"Regex"> |
  kw<"Any"> |
  kw<"Dynamic"> |
  kw<"Typed"> |
  kw<"Listing"> |
  kw<"Mapping"> |
  kw<"Set"> |
  kw<"Map"> |
  kw<"List"> |
  kw<"Collection"> |
  kw<"Iterable"> |
  kw<"Function"> |
  kw<"IntSeq"> |
  kw<"Class"> |
  kw<"TypeAlias"> |
  kw<"Module"> |
  kw<"Resource"> |
  kw<"VarArgs">
}

TypeArguments {
  !typeArgs "<" typeExpression ("," typeExpression)* ">"
}


NullableType {
  TypeAtom "?"
}

ParenthesizedType {
  "(" UnionType ")"
}

modifiers {
  modifier+
}

modifier {
  kw<"hidden"> |
  kw<"local"> |
  kw<"abstract"> |
  kw<"external"> |
  kw<"open"> |
  kw<"in"> |
  kw<"out"> |
  kw<"fixed"> |
  kw<"const"> |
  kw<"extends">
}
  
expression {
  ConditionalExpression |
  BinaryExpression |
  UnaryExpression |
  PostfixExpression
}

ObjectLiteral {
  "{" (objectEntry ("," objectEntry)* ","?)? "}"
}

Block {
  "{" statement* "}"
}

objectEntry {
  (Definition | String | QuotedIdentifier) ":" typeExpression ("=" expression)? |
  (Definition | String | QuotedIdentifier) "=" expression
}

Annotation {
  "@" Identifier
}



BinaryExpression {
  expression !pipe "|>" expression |
  expression !nullCoalesce "??" expression |
  expression !logicalOr "||" expression |
  expression !logicalAnd "&&" expression |
  expression !equality ("==" | "!=") expression |
  expression !comparison (">" | ">=" | "<" | "<=") expression |
  expression !additive ("+" | "-") expression |
  expression !multiplicative ("*" | "/" | "%" | "~/") expression |
  expression !power "**" expression |
  expression kw<"is"> typeExpression |
  expression kw<"as"> typeExpression
}

UnaryExpression {
  !unary ("!" | "-" | "+" | "!!" ) expression
}

ConditionalExpression {
  kw<"if"> "(" expression ")" expression !ifElse kw<"else"> expression |
  kw<"if"> "(" expression ")" expression !ifOnly
}

LambdaExpression {
  !lambda "(" ")" "->" expression |
  !lambda Identifier "->" expression |
  !lambda "(" parameter ("," parameter)+ ")" "->" expression
}



NewExpression {
  kw<"new"> "{" statement* "}" |
  kw<"new"> (QualifiedType | BuiltinType | Identifier) "{" statement* "}"
}

VariableLanguage {
  kw<"this"> |
  kw<"module"> |
  kw<"outer"> |
  kw<"super">
}

SupportType {
  kw<"unknown"> |
  kw<"never">
}

// Contextual identifier types using Java-style approach
ModuleName {
  Identifier ("." Identifier)*
}

// Simple approach - use Identifier everywhere, rely on tree structure for styling
Definition {
  Identifier
}

// Member property names (allow quoted identifiers)
MemberName {
  Identifier |
  QuotedIdentifier
}

argumentList {
  expression ("," expression)*
}

PostfixExpression {
  PrimaryExpression |
  PostfixExpression !call Call |
  PostfixExpression !member "." MemberName |
  PostfixExpression !member "?." MemberName |
  PostfixExpression !member "[" expression "]"
}

Call {
  "(" argumentList? ")"
}

PrimaryExpression {
  Identifier |
  QuotedIdentifier |
  Annotation |
  String |
  Number |
  NewExpression |
  ObjectLiteral |
  VariableLanguage |
  SupportType |
  LambdaExpression |
  "(" expression ")"
}

@tokens {
  @precedence {
    Boolean,
    Number,
    Identifier
  }
  
  identifierChar { @asciiLetter | $[_$\u{a1}-\u{10ffff}] }

  Identifier { identifierChar (identifierChar | @digit)* }

  QuotedIdentifier { "`" ![`]+ "`" }

  String { 
    '"' stringContent* '"' |
    '"""' multiLineStringContent* '"""' |
    hashString1 |
    hashString2 |
    hashString3 |
    hashString4 |
    hashString5 |
    hashString6 |
    hashTripleString1 |
    hashTripleString2 |
    hashTripleString3 |
    hashTripleString4 |
    hashTripleString5 |
    hashTripleString6
  }

  // Simplified hash strings
  hashString1 { '#"' hashStringContent1* '"#' }
  hashString2 { '##"' hashStringContent2* '"##' }
  hashString3 { '###"' hashStringContent3* '"###' }
  hashString4 { '####"' hashStringContent4* '"####' }
  hashString5 { '#####"' hashStringContent5* '"#####' }
  hashString6 { '######"' hashStringContent6* '"######' }
  
  // Triple-quoted hash strings
  hashTripleString1 { '#"""' multiLineStringContent* '"""#' }
  hashTripleString2 { '##"""' multiLineStringContent* '"""##' }
  hashTripleString3 { '###"""' multiLineStringContent* '"""###' }
  hashTripleString4 { '####"""' multiLineStringContent* '"""####' }
  hashTripleString5 { '#####"""' multiLineStringContent* '"""#####' }
  hashTripleString6 { '######"""' multiLineStringContent* '"""######' }
  
  stringContent { !["\\] | "\\" _ }
  hashStringContent1 { !["] | '"' ![#] }
  hashStringContent2 { !["] | '"' ![#] | '"#' ![#] }
  hashStringContent3 { !["] | '"' ![#] | '"#' ![#] | '"##' ![#] }
  hashStringContent4 { !["] | '"' ![#] | '"#' ![#] | '"##' ![#] | '"###' ![#] }
  hashStringContent5 { !["] | '"' ![#] | '"#' ![#] | '"##' ![#] | '"###' ![#] | '"####' ![#] }
  hashStringContent6 { !["] | '"' ![#] | '"#' ![#] | '"##' ![#] | '"###' ![#] | '"####' ![#] | '"#####' ![#] }
  multiLineStringContent { !["] | '"' !["] | '""' !["] }

  Number { 
    "0x" ($[0-9a-fA-F] $[0-9a-fA-F_]* $[0-9a-fA-F] | $[0-9a-fA-F]) |
    "0b" ($[01] $[01_]* $[01] | $[01]) |
    "0o" ($[0-7] $[0-7_]* $[0-7] | $[0-7]) |
    ($[0-9] $[0-9_]* $[0-9] | $[0-9]) ("." ($[0-9] $[0-9_]* $[0-9] | $[0-9]))? ($[eE] $[+\-]? ($[0-9] $[0-9_]* $[0-9] | $[0-9]))?
  }

  Boolean { "true" | "false" | "null" }

  @precedence {
    DocComment,
    LineComment,
    "/"
  }

  LineComment { "//" ![\n]* }

  DocComment { "///" ![\n]* }

  BlockComment[isolate] { "/*" blockCommentRest }

  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }

  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  space { $[ \t\n\r]+ }

  "(" ")" "," "=" "{" "}" "." "->" "[" "]" ":" ";" "`" "@" "?." "#"
  "|>" "??" "||" "&&" "==" "!=" ">" ">=" "<" "<=" 
  "+" "-" "*" "/" "%" "~/" "**" "!" "!!" "|" "?"
}

@detectDelim